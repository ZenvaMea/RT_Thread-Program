# ART-PI 外骨骼手指控制系统 - 开发日志

## 项目概述

**项目名称**：基于肌电信号的外骨骼手指控制系统

**最终目标**：使用肌电臂环采集手臂肌电信号，通过ART-PI处理后驱动4个舵机，实现外骨骼手指的精确控制

**应用场景**：
- 🦾 外骨骼手指辅助系统
- 💪 肌电信号驱动舵机控制
- 🖐️ 四指独立控制（每个舵机驱动一根手指）
- 📊 实时状态显示（串口屏）

**系统架构（最终版）**：
```
┌─────────────────────────────────────────────────────────────┐
│                       控制系统架构                            │
└─────────────────────────────────────────────────────────────┘

  肌电臂环                 ART-PI主控           ESP32驱动板
  (传感器)                (STM32H7R)            (WiFi AP)
     │                        │                     │
     │  肌电信号(UART)         │                     │
     ├───────────────────────>│                     │
     │                        │                     │
     │                        │   WiFi连接          │
     │                        │<───────────────────>│
     │                        │   HTTP命令          │
     │                        │                     │
     │                        │                     │  SCSCL协议
     │                        │                     ├───────────> 舵机0 (食指)
     │                        │                     ├───────────> 舵机1 (中指)
     │      串口屏             │                     ├───────────> 舵机2 (无名指)
     │     (显示)              │                     └───────────> 舵机3 (小指)
     │        │                │
     │        │<───────────────┤
     │        │   UART显示数据  │
     │                        │
     │                   电源供电系统
     │                    (8.4V)
     │                        │
     └────────────────────────┴──────────────────────────────────
                          (共地)
```

**当前阶段**：WiFi舵机控制基础功能（已完成）

**技术栈**：
- **主控**：STM32H7R + RT-Thread RTOS
- **通信**：WiFi (ESP32 AP模式) + HTTP协议
- **舵机**：4个SCSCL舵机（8.4V供电）
- **传感器**：肌电臂环（规划中）
- **显示**：串口屏（规划中）

---

## 2025-11-14 开发记录

### ✅ 完成的功能模块

#### 1. WiFi管理模块 (wifi_manager.c/h)
- WiFi连接和状态管理
- 事件驱动的连接状态跟踪
- IP地址获取
- 连接就绪等待机制

**关键函数**：
```c
int wifi_manager_init(void);
int wifi_connect(const char *ssid, const char *password);
wifi_status_t wifi_get_status(void);
int wifi_get_ip(char *ip_buf, int buf_len);
int wifi_wait_ready(int timeout_ms);
```

**重要修复**：WiFi事件类型从`RT_WLAN_DEV_EVT_xxx`修正为`RT_WLAN_EVT_xxx`

#### 2. HTTP客户端模块 (servo_http_client.c/h)
- 基于Socket的HTTP GET实现
- URL解析和连接管理
- 超时控制
- 简化接口支持

**关键函数**：
```c
int http_client_init(void);
int http_get(const char *url, http_response_t *response, int timeout_ms);
int http_get_simple(const char *url);
```

#### 3. 基础舵机控制模块 (servo_control.c/h)
- 单舵机基础控制接口
- 支持位置、速度、模式、扭矩控制
- ESP32 HTTP命令封装

**控制命令**：
- `servo_move_middle()` - 移动到中间位置
- `servo_move_max()` - 移动到最大位置
- `servo_move_min()` - 移动到最小位置
- `servo_stop()` - 停止运动
- `servo_enable_torque(int enable)` - 扭矩开关
- `servo_set_speed(int increase)` - 速度调节
- `servo_select_next(int direction)` - 切换舵机

#### 4. 高级舵机控制模块 (servo_advanced.c/h)
- 多舵机协同控制
- 按ID直接控制任意舵机
- 批量控制多个舵机
- 4级速度控制系统
- 动作序列编程
- 预设动作支持
- 线程安全保护（互斥锁）

**速度级别定义**：
| 级别 | 宏定义 | 数值 |
|------|--------|------|
| 慢速 | SERVO_SPEED_SLOW | 1 |
| 中速 | SERVO_SPEED_MEDIUM | 2 |
| 快速 | SERVO_SPEED_FAST | 3 |
| 最快 | SERVO_SPEED_MAX | 4 |

**位置定义**：
| 位置 | 宏定义 | 数值 |
|------|--------|------|
| 中间 | SERVO_POS_MIDDLE | 0 |
| 最大 | SERVO_POS_MAX | 1 |
| 最小 | SERVO_POS_MIN | 2 |

**核心API**：
```c
// 按ID控制
int servo_move_by_id_speed(int servo_id, int position, int speed);

// 全舵机控制
int servo_all_middle_speed(int speed);
int servo_all_stop(void);
int servo_all_torque(int enable);
int servo_all_set_speed(int speed);

// 批量控制
int servo_multi_move_speed(int *servo_ids, int *positions, int *speeds, int count);

// 动作序列
int servo_execute_sequence(servo_action_t *actions, int count);

// 预设动作
int servo_preset_home(void);
int servo_preset_wave(int cycles, int speed);
int servo_preset_sequence(int speed);
```

**高级MSH命令** (servo_msh_advanced.c)：
```shell
# 按ID控制
serv move 0 0 2          # 舵机0移到中间，中速
serv move 1 1 4          # 舵机1移到最大，最快

# 全舵机控制
serv all_mid 3           # 所有舵机回中位，快速
serv all_stop            # 停止所有舵机
serv all_ton             # 打开所有舵机扭矩
serv all_toff            # 关闭所有舵机扭矩
serv all_speed 4         # 设置所有舵机最快速度

# 批量控制
serv multi 0,1,2 0,1,2   # 舵机0,1,2到中间,最大,最小

# 预设动作
serv home                # 所有舵机回中位
serv wave 3 2            # 波浪动作3次，中速
serv seq 2               # 依次动作，中速

# 测试命令
servo_test               # 自动测试所有舵机
```

#### 5. 主程序集成 (main.c)
- 初始化所有功能模块
- 显示快速使用指南

**初始化流程**：
```c
wifi_manager_init();
http_client_init();
servo_control_init(NULL);
servo_advanced_init();
```

---

### 🐛 解决的问题

#### 问题1：WiFi事件类型错误
**现象**：编译错误 `RT_WLAN_EVT_CONNECT undeclared`

**原因**：使用了错误的事件枚举类型

**解决**：更正为RT-Thread WLAN框架标准事件类型

- `RT_WLAN_EVT_READY` - WiFi就绪
- `RT_WLAN_EVT_STA_CONNECTED` - STA模式连接成功
- `RT_WLAN_EVT_STA_DISCONNECTED` - STA模式断开连接
- `RT_WLAN_EVT_STA_CONNECTED_FAIL` - STA模式连接失败

#### 问题2：标准库函数未声明
**现象**：`implicit declaration of function 'atoi'`, `'sscanf'`

**原因**：缺少标准库头文件

**解决**：添加 `#include <stdlib.h>` 和 `#include <stdio.h>`

#### 问题3：Socket超时结构体大小未知
**现象**：`storage size of 'timeout' isn't known`

**原因**：RT-Thread的lwIP实现不使用`struct timeval`

**解决**：改用整数超时值 `int timeout_sec`

#### 问题4：IP地址类型未定义
**现象**：`unknown type name 'ip_addr_t'`

**原因**：缺少lwIP网络接口头文件

**解决**：

- 添加 `#include <lwip/netif.h>` 和 `#include <lwip/inet.h>`
- 使用 `inet_ntoa()` 简化IP地址获取

#### 问题5：WiFi连接超时（运行时）
**现象**：连接WiFi后一直提示"Wait WiFi ready timeout"

**原因**：事件回调注册了`RT_WLAN_EVT_READY`但实际使用了错误的连接事件类型

**解决**：统一使用`RT_WLAN_EVT_STA_CONNECTED`等正确的事件类型

#### 问题6：舵机异常抖动（硬件问题）⭐
**现象**：执行命令后舵机会出现异常抖动、发热、响应不稳定

**初步分析**：以为是软件延时、命令时序等问题

**真正原因**：**电源电压不匹配！**

- 舵机额定电压：**8.4V**
- 实际输入电压：**12V**
- 过压约42.8%，超出舵机安全工作范围

**解决方案**：使用DC-DC降压模块将12V降至8.4V（详见下文"硬件调试经验"）

---

### 💡 硬件调试经验：舵机电源电压选择

#### 问题发现过程
在软件开发完成后，舵机出现异常抖动现象。最初以为是：
- 软件命令发送过快
- 网络延迟导致命令堆积
- 舵机控制时序问题

但经过硬件检查发现：**电源电压不匹配才是根本原因！**

#### 舵机电压电流基础知识

##### 1. 额定电压 vs 输入电压
```
┌────────────────────────────────────────┐
│  舵机规格参数                            │
├────────────────────────────────────────┤
│  额定电压：8.4V (标称工作电压)            │
│  电压范围：7.2V - 8.4V (安全范围)         │
│  实际输入：12V ❌ (超压42.8%)             │
└────────────────────────────────────────┘
```

**电压过高的危害**：
- ⚠️ **舵机抖动**：电机驱动电压过高，PWM控制失效
- ⚠️ **发热严重**：功率 P = U²/R，电压升高导致功率平方级增长
- ⚠️ **寿命缩短**：长期过压工作会损坏内部电机和电路
- ⚠️ **控制失灵**：内部电路可能因过压保护而工作异常
- ⚠️ **烧毁风险**：严重过压可能直接烧坏舵机

**电压过低的问题**：
- 扭矩不足，无法驱动负载
- 速度变慢，响应迟钝
- 堵转时可能无法启动

##### 2. 常见舵机电压规格对照表

| 舵机类型 | 额定电压 | 电压范围 | 典型应用 |
|---------|---------|---------|---------|
| 模拟舵机 | 4.8V - 6.0V | 4.5V - 6.5V | 小型机器人、航模 |
| 数字舵机 | 6.0V - 7.4V | 5.5V - 8.4V | 中型机器人、无人机 |
| 高压数字舵机 | 7.4V - 8.4V | 7.2V - 8.4V | 大型机器人、机械臂 |
| 工业舵机 | 12V / 24V | ±10% | 工业自动化设备 |

**本项目使用的SCSCL舵机**：
- 额定电压：**8.4V** (2S锂电池电压)
- 安全范围：**7.2V - 8.4V**
- 不能直接使用12V供电！

##### 3. 舵机电流需求计算

单个舵机电流消耗：
```
空载电流：    约 100-200mA
运动电流：    约 300-500mA
堵转电流：    约 800-1200mA (瞬时)
```

**4个舵机同时工作的电流需求**：
```
空载总电流：  4 × 200mA   = 0.8A
运动总电流：  4 × 500mA   = 2.0A
堵转总电流：  4 × 1200mA  = 4.8A (峰值)
```

**电源容量选择建议**：
- 最小持续电流：**2A**
- 推荐持续电流：**3A**
- 峰值电流能力：**5A**

**电源功率计算**：
```
额定功率 = 8.4V × 3A = 25.2W
建议选择：30W 或以上的电源适配器
```

#### 电压转换解决方案

##### 方案1：DC-DC降压模块（推荐）⭐

**推荐型号**：
- **LM2596 降压模块**
  - 输入：4.5V - 40V
  - 输出：1.25V - 37V 可调
  - 最大电流：3A
  - 效率：92%
  - 价格：5-10元

- **XL4015 降压模块**（大电流版本）
  - 输入：8V - 36V
  - 输出：1.25V - 32V 可调
  - 最大电流：5A
  - 效率：96%
  - 价格：10-15元

**接线方法**：
```
12V电源 ──┬──> DC-DC降压模块 ──> 8.4V输出 ──> 舵机VCC
          │         ↓                          ↓
          └──────> GND ────────────────────> GND
```

**调节步骤**：
1. 不接负载，先给降压模块供电
2. 用万用表测量输出端电压
3. 调节模块上的电位器，将输出调至**8.4V**
4. 反复微调，确保电压稳定在8.4V ±0.1V
5. 连接舵机，再次测量带载电压（可能略有下降）
6. 微调至8.4V

##### 方案2：线性稳压器（小功率）

**适用场景**：单个舵机，功率小于5W

**型号选择**：
- **LM7808** (输出8V，1A)
- **LM317** (可调输出，1.5A)

**缺点**：
- 效率低（约60-70%）
- 发热严重（12V→8.4V，约30%能量变成热量）
- 需要大散热片
- 不适合多舵机应用

##### 方案3：使用专用舵机电源

**推荐产品**：
- 8.4V / 3A 开关电源适配器
- 2S锂电池（7.4V标称，8.4V满电）

**优点**：
- 电压完全匹配
- 无需额外转换
- 效率最高

**2S锂电池方案**：
```
2S锂电池（7.4V/8.4V）
├─ 容量：2200mAh - 5000mAh
├─ 持续放电：20C - 30C
├─ 工作时间：2200mAh ÷ 2A = 1小时以上
└─ 需要专用充电器
```

##### 方案4：分离供电（最佳方案）

**系统架构**：
```
12V电源 ──┬──> ART-PI主板 (12V/5V)
          │
          ├──> ESP32驱动板 (5V/3.3V)
          │
          └──> DC-DC降压 ──> 8.4V ──> 4个舵机
                                     (共地)
```

**优点**：
- 各部分电压独立，互不干扰
- 舵机大电流不影响控制板
- 便于故障排查
- 最稳定的供电方案

**注意事项**：
- ⚠️ **必须共地**：所有电源的GND必须连接在一起
- ⚠️ **粗线供电**：舵机电源线建议使用≥20AWG（0.5mm²）
- ⚠️ **电容滤波**：在舵机电源端并联1000μF电容，减少电流尖峰

#### 电源问题诊断方法

##### 1. 用万用表测量电压
```
测量点：
1. 电源输出端空载电压
2. 电源输出端带载电压（舵机运行时）
3. 舵机VCC引脚电压
4. 舵机运动瞬间的电压降

判断标准：
✓ 空载与带载电压差 < 0.5V  → 电源容量足够
✗ 空载与带载电压差 > 1.0V  → 电源容量不足
✗ 运动瞬间电压跌落 > 1.5V  → 需要加大滤波电容
```

##### 2. 观察舵机工作状态
```
正常工作：
✓ 运动平稳，无抖动
✓ 速度均匀
✓ 无异常声音
✓ 舵机外壳不发热（微温正常）

电压过高：
✗ 抖动、颤动
✗ 异常发热
✗ 有刺耳声音
✗ 控制失灵

电压过低：
✗ 扭矩不足
✗ 速度慢
✗ 堵转无力
```

##### 3. 电流测量
使用电流表串联测量：
```
电流表 ──> 舵机VCC

正常电流：
空载：    100-200mA
运动：    300-500mA
堵转：    800-1200mA

异常电流：
> 1500mA持续  → 电压过低或机械卡死
< 50mA        → 舵机损坏或未通电
```

#### 实际应用建议

**本项目最佳配置**：
```
方案：12V输入 + DC-DC降压

硬件清单：
1. XL4015降压模块 (5A) × 1    ￥12
2. 12V/3A电源适配器 × 1       ￥20
3. 1000μF/16V电解电容 × 2     ￥2
4. 杜邦线/端子线若干           ￥5
   总成本：约￥40

接线图：
                    ┌─────────────┐
    12V电源 ────────┤ DC-DC降压   │
       GND ─────────┤  (调至8.4V)  ├────┬──> 舵机0 VCC
                    └─────────────┘    ├──> 舵机1 VCC
                         │             ├──> 舵机2 VCC
                        GND ───────────┴──> 舵机3 VCC
                         │                      │
                         └──────────────────────┘
                                   (共地)
```

**调试步骤**：
1. ✅ 调节降压模块输出至8.4V（空载）
2. ✅ 连接单个舵机，测量电压（应≥8.2V）
3. ✅ 连接所有舵机，测量电压（应≥8.0V）
4. ✅ 让舵机运动，观察电压波动（应≤0.5V）
5. ✅ 如电压降过大，增加滤波电容或更换更大功率模块

**长期使用注意事项**：
- 🔍 定期检查舵机温度（正常应≤40℃）
- 🔍 定期测量电源电压（防止元件老化导致输出漂移）
- 🔍 观察舵机运动是否平稳
- 🔍 检查接线端子是否松动

---

### 📚 知识扩展：电源设计要点

#### 1. 为什么不能用电阻分压？
```
12V ──┬─── 100Ω ───┬─── 输出
      │            │
      └─── 200Ω ───┴─── GND

理论输出 = 12V × 200/(100+200) = 8V
```

**问题**：
- ✗ 电阻分压输出电压会随负载变化
- ✗ 舵机电流大（0.5A），电阻功耗 = I²R，会发热严重
- ✗ 效率极低，大部分能量浪费在电阻上
- ✗ 电压不稳定，根本无法使用

#### 2. DC-DC降压原理（开关电源）
```
工作原理：通过高频开关+电感储能实现降压
效率：90-96%（远高于线性稳压）
优点：高效、发热小、输出稳定
```

#### 3. 功率预算计算
```
系统总功率计算：
┌─────────────────────────────────┐
│ ART-PI主板    :  0.5W  (5V/100mA) │
│ ESP32驱动板   :  1.0W  (5V/200mA) │
│ 4个舵机(运动) : 16.8W  (8.4V/2A)  │
│ 合计          : 18.3W             │
│ 余量(×1.5)    : 27.5W             │
│ 推荐电源      : 30W               │
└─────────────────────────────────┘
```

#### 4. 滤波电容的作用
```
作用：
1. 平滑电压波动
2. 抑制电流尖峰（舵机启动瞬间）
3. 改善高频噪声

选择：
- 容值：1000μF - 2200μF
- 耐压：≥ 1.5倍工作电压（8.4V用16V电容）
- 类型：低ESR电解电容
- 位置：尽量靠近舵机电源引脚
```

---

### 🎯 技术特点

1. **智能舵机切换**：自动跟踪当前活动舵机ID，最小化HTTP请求次数
2. **线程安全设计**：使用互斥锁保护，支持多线程调用
3. **灵活速度控制**：4级速度可调，适应不同应用场景
4. **批量操作优化**：一次性控制多个舵机，提高效率
5. **动作序列编程**：支持复杂动作组合，延时控制精确
6. **预设动作库**：常用动作一键执行，简化测试和演示
7. **电源管理经验**：正确的电压选择是硬件稳定运行的基础

---

### 📝 使用示例

#### 快速开始
```shell
# 1. 连接ESP32的WiFi
connect_esp32

# 2. 控制单个舵机
serv move 0 0 2          # 舵机0到中间位置，中速

# 3. 控制所有舵机
serv all_mid 3           # 所有舵机快速回中位

# 4. 波浪演示
serv wave 3 2            # 执行3次波浪动作

# 5. 全功能测试
servo_test
```

#### 编程示例
```c
// 复杂动作序列
void custom_action(void)
{
    // 舵机0和1同时向上
    int ids1[] = {0, 1};
    int pos1[] = {SERVO_POS_MAX, SERVO_POS_MAX};
    servo_multi_move(ids1, pos1, 2);
    rt_thread_mdelay(1000);

    // 舵机2和3同时向下
    int ids2[] = {2, 3};
    int pos2[] = {SERVO_POS_MIN, SERVO_POS_MIN};
    servo_multi_move(ids2, pos2, 2);
    rt_thread_mdelay(1000);

    // 所有舵机回中位
    servo_all_middle();
}
```

---

### 📂 项目文件结构

```
Cc/applications/
├── main.c                      # 主程序
├── wifi_manager.c/h            # WiFi管理模块
├── servo_http_client.c/h       # HTTP客户端模块
├── servo_control.c/h           # 基础舵机控制
├── servo_advanced.c/h          # 高级舵机控制
└── servo_msh_advanced.c        # 高级MSH命令
```

---

### 🔄 下一步开发计划

#### 阶段2：串口屏显示模块（即将开始）📱

**功能需求**：
- 实时显示WiFi连接状态
- 显示4个舵机当前位置和状态
- 显示肌电信号强度（图形化）
- 显示系统运行状态和错误信息
- 支持触摸操作（可选）

**技术方案**：
```
串口屏型号建议：
- 迪文/大彩 串口屏
- 尺寸：3.5寸 - 7寸
- 通信：UART (115200bps)
- 协议：简单指令协议
```

**开发任务**：
1. **UART驱动配置**
   - 配置RT-Thread UART设备
   - 波特率：115200
   - 数据格式：8N1

2. **显示协议封装**
   - 封装串口屏指令集
   - 文本显示函数
   - 图形绘制函数
   - 界面布局设计

3. **界面设计**
   ```
   ┌─────────────────────────────┐
   │  外骨骼手指控制系统 v1.0     │
   ├─────────────────────────────┤
   │ WiFi: ●已连接 192.168.4.10  │
   │                             │
   │ 舵机状态:                    │
   │  [食指  ] ████████░░ 80%    │
   │  [中指  ] ██████░░░░ 60%    │
   │  [无名指] ████░░░░░░ 40%    │
   │  [小指  ] ██░░░░░░░░ 20%    │
   │                             │
   │ 肌电信号:                    │
   │  通道1: ▂▃▅▇█▇▅▃▂ 65%      │
   │  通道2: ▂▃▄▅▄▃▂▁ 45%       │
   │                             │
   │ 系统: 运行正常  温度: 35℃   │
   └─────────────────────────────┘
   ```

4. **数据更新策略**
   - 使用RT-Thread线程定时刷新
   - 更新频率：10-20Hz
   - 局部刷新减少闪烁

**预计工作量**：2-3天

---

#### 阶段3：肌电信号采集与处理（核心功能）💪

**功能需求**：
- 通过UART接收肌电臂环数据
- 实时处理肌电信号
- 将肌电强度映射到舵机位置
- 支持阈值调节和死区设置
- 四通道独立控制四个手指

**技术方案**：

##### 1. 肌电臂环接口
```c
/* 肌电数据结构 */
typedef struct {
    uint16_t channel[4];      // 4通道肌电值 (0-1023)
    uint8_t  valid;           // 数据有效标志
    uint32_t timestamp;       // 时间戳
} emg_data_t;

/* 肌电采集API */
int emg_init(const char *uart_name);
int emg_read(emg_data_t *data, int timeout_ms);
int emg_calibrate(void);  // 校准函数
```

##### 2. 信号处理流程
```
原始肌电信号 (ADC值)
    ↓
滤波处理 (移动平均/低通滤波)
    ↓
幅值检测 (RMS/MAV)
    ↓
归一化 (0-100%)
    ↓
阈值判断 (死区+灵敏度)
    ↓
映射到舵机位置 (0-180°)
    ↓
舵机控制命令
```

##### 3. 映射算法
```c
/**
 * @brief 肌电信号到舵机位置的映射
 * @param emg_value  肌电信号强度 (0-100)
 * @param threshold  触发阈值 (10-30)
 * @param deadzone   死区范围 (0-10)
 * @return 舵机位置 (0=最小, 1=中间, 2=最大)
 */
int emg_to_servo_position(int emg_value, int threshold, int deadzone)
{
    if (emg_value < threshold + deadzone) {
        return SERVO_POS_MIN;  // 放松状态
    }
    else if (emg_value < 50 + deadzone) {
        return SERVO_POS_MIDDLE;  // 半握
    }
    else {
        return SERVO_POS_MAX;  // 全握
    }
}
```

##### 4. 实时控制线程
```c
/* 肌电控制线程 */
void emg_control_thread_entry(void *parameter)
{
    emg_data_t emg_data;
    int servo_positions[4];

    while (1)
    {
        // 1. 读取肌电数据
        if (emg_read(&emg_data, 100) == 0)
        {
            // 2. 处理每个通道
            for (int i = 0; i < 4; i++)
            {
                // 信号处理
                int emg_value = process_emg_signal(emg_data.channel[i]);

                // 映射到舵机位置
                servo_positions[i] = emg_to_servo_position(
                    emg_value,
                    g_config.threshold[i],
                    g_config.deadzone
                );
            }

            // 3. 批量控制舵机
            servo_multi_move(
                (int[]){0, 1, 2, 3},
                servo_positions,
                4
            );

            // 4. 更新显示
            display_update_emg(emg_data.channel, 4);
            display_update_servo(servo_positions, 4);
        }

        rt_thread_mdelay(50);  // 20Hz控制频率
    }
}
```

##### 5. 校准流程
```
校准步骤：
1. 采集静息状态基线（5秒）
2. 采集最大收缩值（用力握拳，3次×3秒）
3. 计算动态阈值
4. 保存校准参数到Flash

校准参数：
- baseline[4]：静息基线
- max_value[4]：最大值
- threshold[4]：触发阈值 = baseline + (max - baseline) * 0.3
- deadzone：死区 = (max - baseline) * 0.1
```

**开发任务**：
1. ✅ **UART通信驱动**
   - 配置肌电臂环UART端口
   - 数据帧格式解析
   - CRC校验（如果有）

2. ✅ **信号处理模块**
   - 移动平均滤波器
   - RMS幅值计算
   - 归一化处理

3. ✅ **映射算法实现**
   - 线性映射
   - 非线性映射（可选：S曲线）
   - 阈值和死区处理

4. ✅ **实时控制线程**
   - 周期性采集肌电数据
   - 实时处理和控制
   - 错误处理和超时保护

5. ✅ **校准功能**
   - 交互式校准流程
   - 参数保存和加载
   - MSH校准命令

6. ✅ **性能优化**
   - 减少延迟（目标<50ms）
   - 平滑控制（防止抖动）
   - 资源占用优化

**预计工作量**：5-7天

---

#### 阶段4：系统集成与优化

**功能需求**：
- 三模式切换：手动模式、肌电模式、演示模式
- 参数配置界面（通过串口屏）
- 数据记录和回放
- 故障诊断和安全保护

**开发任务**：
1. **模式管理**
   ```c
   typedef enum {
       MODE_MANUAL,    // 手动模式（MSH命令）
       MODE_EMG,       // 肌电控制模式
       MODE_DEMO,      // 演示模式（预设动作）
   } control_mode_t;
   ```

2. **安全保护**
   - 过流保护检测
   - 超温保护
   - 失控保护（肌电信号丢失）
   - 紧急停止功能

3. **参数配置系统**
   - 舵机速度、位置范围
   - 肌电阈值、死区、灵敏度
   - 显示刷新率
   - 参数持久化存储

4. **性能优化**
   - 降低系统延迟
   - 优化电源管理
   - 代码优化和重构

**预计工作量**：3-4天

---

#### 阶段5：测试与完善

**测试内容**：
1. **功能测试**
   - 单舵机控制测试
   - 多舵机协同测试
   - 肌电信号响应测试
   - 显示界面测试

2. **性能测试**
   - 延迟测试（肌电信号→舵机响应）
   - 稳定性测试（长时间运行）
   - 精度测试（位置控制精度）

3. **极限测试**
   - 快速连续动作
   - 负载测试
   - 环境适应性

4. **用户体验测试**
   - 佩戴舒适度
   - 控制灵敏度
   - 疲劳度测试

**预计工作量**：3-5天

---

### 📅 总体时间规划

```
┌──────────────────────────────────────────────────────┐
│                   项目时间轴                          │
├──────────────────────────────────────────────────────┤
│ 阶段1: WiFi舵机控制        │ ✅ 已完成 (2025-11-14)  │
│ 阶段2: 串口屏显示          │ ⏳                     │
│ 阶段3: 肌电信号控制        │ ⏳                     │
│ 阶段4: 系统集成优化        │ ⏳                     │
│ 阶段5: 测试与完善          │ ⏳                     │
├──────────────────────────────────────────────────────┤
│ 预计总工期: 2                                         │
└──────────────────────────────────────────────────────┘
```

---

### 🎯 项目里程碑

- ✅ **里程碑1**：WiFi舵机控制基础功能（已完成）
- 🎯 **里程碑2**：串口屏显示系统状态
- 🎯 **里程碑3**：肌电信号实时控制单手指
- 🎯 **里程碑4**：四指独立控制
- 🎯 **里程碑5**：完整系统演示

---

### 💡 技术难点预判

#### 难点1：肌电信号噪声处理
**挑战**：肌电信号容易受到环境干扰
**解决方案**：
- 硬件滤波（如果臂环支持）
- 软件多级滤波（移动平均+卡尔曼滤波）
- 自适应阈值调整

#### 难点2：控制延迟优化
**挑战**：WiFi通信+HTTP协议存在延迟
**解决方案**：
- 优化HTTP请求（保持连接、减少握手）
- 批量发送命令（4个舵机一次发送）
- 预测性控制（根据肌电变化趋势）

#### 难点3：舵机响应平滑度
**挑战**：直接映射会导致舵机抖动
**解决方案**：
- 信号平滑处理（滑动窗口）
- 位置差值插补
- 速度限制保护

#### 难点4：电源管理
**挑战**：4个舵机同时动作电流大
**解决方案**：
- 已解决：DC-DC降压至8.4V
- 增加大容量电容
- 监控电压降，必要时降低速度

---

### 💡 重要提示

#### 软件使用
1. **使用前必须先连接WiFi**：`connect_esp32`
2. **舵机ID范围**：0-3（共4个舵机）
3. **速度级别**：1-4，0表示使用当前速度
4. **位置定义**：0=中间，1=最大，2=最小
5. **线程安全**：所有API均可在多线程中调用
6. **ESP32地址**：默认192.168.4.1（AP模式）

#### 硬件注意事项 ⚠️
1. **电压匹配**：舵机额定8.4V，必须使用降压模块，不能直接12V供电！
2. **电流容量**：4个舵机至少需要3A电源
3. **共地连接**：所有电源GND必须连接
4. **滤波电容**：建议在舵机电源端并联1000μF电容
5. **定期检查**：测量电压、观察温度、检查接线

---

## 开发统计

- **开发日期**：2025-11-14
- **代码文件**：10个（.c/.h）
- **MSH命令**：15+个
- **API函数**：30+个
- **解决问题**：6个（5个软件 + 1个硬件）
- **功能模块**：4个主要模块
- **硬件调试**：1个重要经验（电源电压）

---

## 参考资料

- RT-Thread官方文档
- ESP32 Arduino参考
- SCSCL舵机协议文档
- lwIP网络栈文档
- DC-DC降压模块应用笔记
- 舵机电源设计指南
