# ART-PI 外骨骼手指控制系统 - 开发日志

## 项目概述

**项目名称**：基于肌电信号的外骨骼手指控制系统

**最终目标**：使用肌电臂环采集手臂肌电信号，通过ART-PI处理后驱动4个舵机，实现外骨骼手指的精确控制

**应用场景**：
- 🦾 外骨骼手指辅助系统
- 💪 肌电信号驱动舵机控制
- 🖐️ 四指独立控制（每个舵机驱动一根手指）
- 📊 实时状态显示（串口屏）

**系统架构（最终版）**：
```
┌─────────────────────────────────────────────────────────────┐
│                       控制系统架构                            │
└─────────────────────────────────────────────────────────────┘

  肌电臂环                 ART-PI主控           ESP32驱动板
  (传感器)                (STM32H7R)            (WiFi AP)
     │                        │                     │
     │  肌电信号(UART)         │                     │
     ├───────────────────────>│                     │
     │                        │                     │
     │                        │   WiFi连接          │
     │                        │<───────────────────>│
     │                        │   HTTP命令          │
     │                        │                     │
     │                        │                     │  SCSCL协议
     │                        │                     ├───────────> 舵机0 (食指)
     │                        │                     ├───────────> 舵机1 (中指)
     │      串口屏             │                     ├───────────> 舵机2 (无名指)
     │     (显示)              │                     └───────────> 舵机3 (小指)
     │        │                │
     │        │<───────────────┤
     │        │   UART显示数据  │
     │                        │
     │                   电源供电系统
     │                    (8.4V)
     │                        │
     └────────────────────────┴──────────────────────────────────
                          (共地)
```

**当前阶段**：串口屏显示功能（已完成）

**技术栈**：
- **主控**：STM32H7R + RT-Thread RTOS
- **通信**：WiFi (ESP32 AP模式) + HTTP协议
- **舵机**：4个SCSCL舵机（8.4V供电）
- **显示**：TJC/迪文串口屏（UART1通信）
- **传感器**：肌电臂环（规划中）

---

## 2025-11-14 开发记录

### ✅ 完成的功能模块

#### 1. WiFi管理模块 (wifi_manager.c/h)
- WiFi连接和状态管理
- 事件驱动的连接状态跟踪
- IP地址获取
- 连接就绪等待机制

**关键函数**：
```c
int wifi_manager_init(void);
int wifi_connect(const char *ssid, const char *password);
wifi_status_t wifi_get_status(void);
int wifi_get_ip(char *ip_buf, int buf_len);
int wifi_wait_ready(int timeout_ms);
```

**重要修复**：WiFi事件类型从`RT_WLAN_DEV_EVT_xxx`修正为`RT_WLAN_EVT_xxx`

#### 2. HTTP客户端模块 (servo_http_client.c/h)
- 基于Socket的HTTP GET实现
- URL解析和连接管理
- 超时控制
- 简化接口支持

**关键函数**：
```c
int http_client_init(void);
int http_get(const char *url, http_response_t *response, int timeout_ms);
int http_get_simple(const char *url);
```

#### 3. 基础舵机控制模块 (servo_control.c/h)
- 单舵机基础控制接口
- 支持位置、速度、模式、扭矩控制
- ESP32 HTTP命令封装

**控制命令**：
- `servo_move_middle()` - 移动到中间位置
- `servo_move_max()` - 移动到最大位置
- `servo_move_min()` - 移动到最小位置
- `servo_stop()` - 停止运动
- `servo_enable_torque(int enable)` - 扭矩开关
- `servo_set_speed(int increase)` - 速度调节
- `servo_select_next(int direction)` - 切换舵机

#### 4. 高级舵机控制模块 (servo_advanced.c/h)
- 多舵机协同控制
- 按ID直接控制任意舵机
- 批量控制多个舵机
- 4级速度控制系统
- 动作序列编程
- 预设动作支持
- 线程安全保护（互斥锁）

**速度级别定义**：
| 级别 | 宏定义 | 数值 |
|------|--------|------|
| 慢速 | SERVO_SPEED_SLOW | 1 |
| 中速 | SERVO_SPEED_MEDIUM | 2 |
| 快速 | SERVO_SPEED_FAST | 3 |
| 最快 | SERVO_SPEED_MAX | 4 |

**位置定义**：
| 位置 | 宏定义 | 数值 |
|------|--------|------|
| 中间 | SERVO_POS_MIDDLE | 0 |
| 最大 | SERVO_POS_MAX | 1 |
| 最小 | SERVO_POS_MIN | 2 |

**核心API**：
```c
// 按ID控制
int servo_move_by_id_speed(int servo_id, int position, int speed);

// 全舵机控制
int servo_all_middle_speed(int speed);
int servo_all_stop(void);
int servo_all_torque(int enable);
int servo_all_set_speed(int speed);

// 批量控制
int servo_multi_move_speed(int *servo_ids, int *positions, int *speeds, int count);

// 动作序列
int servo_execute_sequence(servo_action_t *actions, int count);

// 预设动作
int servo_preset_home(void);
int servo_preset_wave(int cycles, int speed);
int servo_preset_sequence(int speed);
```

**高级MSH命令** (servo_msh_advanced.c)：
```shell
# 按ID控制
serv move 0 0 2          # 舵机0移到中间，中速
serv move 1 1 4          # 舵机1移到最大，最快

# 全舵机控制
serv all_mid 3           # 所有舵机回中位，快速
serv all_stop            # 停止所有舵机
serv all_ton             # 打开所有舵机扭矩
serv all_toff            # 关闭所有舵机扭矩
serv all_speed 4         # 设置所有舵机最快速度

# 批量控制
serv multi 0,1,2 0,1,2   # 舵机0,1,2到中间,最大,最小

# 预设动作
serv home                # 所有舵机回中位
serv wave 3 2            # 波浪动作3次，中速
serv seq 2               # 依次动作，中速

# 测试命令
servo_test               # 自动测试所有舵机
```

#### 5. 主程序集成 (main.c)
- 初始化所有功能模块
- 显示快速使用指南

**初始化流程**：
```c
wifi_manager_init();
http_client_init();
servo_control_init(NULL);
servo_advanced_init();
```

---

### 🐛 解决的问题

#### 问题1：WiFi事件类型错误
**现象**：编译错误 `RT_WLAN_EVT_CONNECT undeclared`

**原因**：使用了错误的事件枚举类型

**解决**：更正为RT-Thread WLAN框架标准事件类型

- `RT_WLAN_EVT_READY` - WiFi就绪
- `RT_WLAN_EVT_STA_CONNECTED` - STA模式连接成功
- `RT_WLAN_EVT_STA_DISCONNECTED` - STA模式断开连接
- `RT_WLAN_EVT_STA_CONNECTED_FAIL` - STA模式连接失败

#### 问题2：标准库函数未声明
**现象**：`implicit declaration of function 'atoi'`, `'sscanf'`

**原因**：缺少标准库头文件

**解决**：添加 `#include <stdlib.h>` 和 `#include <stdio.h>`

#### 问题3：Socket超时结构体大小未知
**现象**：`storage size of 'timeout' isn't known`

**原因**：RT-Thread的lwIP实现不使用`struct timeval`

**解决**：改用整数超时值 `int timeout_sec`

#### 问题4：IP地址类型未定义
**现象**：`unknown type name 'ip_addr_t'`

**原因**：缺少lwIP网络接口头文件

**解决**：

- 添加 `#include <lwip/netif.h>` 和 `#include <lwip/inet.h>`
- 使用 `inet_ntoa()` 简化IP地址获取

#### 问题5：WiFi连接超时（运行时）
**现象**：连接WiFi后一直提示"Wait WiFi ready timeout"

**原因**：事件回调注册了`RT_WLAN_EVT_READY`但实际使用了错误的连接事件类型

**解决**：统一使用`RT_WLAN_EVT_STA_CONNECTED`等正确的事件类型

#### 问题6：舵机异常抖动（硬件问题）⭐
**现象**：执行命令后舵机会出现异常抖动、发热、响应不稳定

**初步分析**：以为是软件延时、命令时序等问题

**真正原因**：**电源电压不匹配！**

- 舵机额定电压：**8.4V**
- 实际输入电压：**12V**
- 过压约42.8%，超出舵机安全工作范围

**解决方案**：使用DC-DC降压模块将12V降至8.4V（详见下文"硬件调试经验"）

---

### 💡 硬件调试经验：舵机电源电压选择

#### 问题发现过程
在软件开发完成后，舵机出现异常抖动现象。最初以为是：
- 软件命令发送过快
- 网络延迟导致命令堆积
- 舵机控制时序问题

但经过硬件检查发现：**电源电压不匹配才是根本原因！**

#### 舵机电压电流基础知识

##### 1. 额定电压 vs 输入电压
```
┌────────────────────────────────────────┐
│  舵机规格参数                            │
├────────────────────────────────────────┤
│  额定电压：8.4V (标称工作电压)            │
│  电压范围：7.2V - 8.4V (安全范围)         │
│  实际输入：12V ❌ (超压42.8%)             │
└────────────────────────────────────────┘
```

**电压过高的危害**：
- ⚠️ **舵机抖动**：电机驱动电压过高，PWM控制失效
- ⚠️ **发热严重**：功率 P = U²/R，电压升高导致功率平方级增长
- ⚠️ **寿命缩短**：长期过压工作会损坏内部电机和电路
- ⚠️ **控制失灵**：内部电路可能因过压保护而工作异常
- ⚠️ **烧毁风险**：严重过压可能直接烧坏舵机

**电压过低的问题**：
- 扭矩不足，无法驱动负载
- 速度变慢，响应迟钝
- 堵转时可能无法启动

##### 2. 常见舵机电压规格对照表

| 舵机类型 | 额定电压 | 电压范围 | 典型应用 |
|---------|---------|---------|---------|
| 模拟舵机 | 4.8V - 6.0V | 4.5V - 6.5V | 小型机器人、航模 |
| 数字舵机 | 6.0V - 7.4V | 5.5V - 8.4V | 中型机器人、无人机 |
| 高压数字舵机 | 7.4V - 8.4V | 7.2V - 8.4V | 大型机器人、机械臂 |
| 工业舵机 | 12V / 24V | ±10% | 工业自动化设备 |

**本项目使用的SCSCL舵机**：
- 额定电压：**8.4V** (2S锂电池电压)
- 安全范围：**7.2V - 8.4V**
- 不能直接使用12V供电！

##### 3. 舵机电流需求计算

单个舵机电流消耗：
```
空载电流：    约 100-200mA
运动电流：    约 300-500mA
堵转电流：    约 800-1200mA (瞬时)
```

**4个舵机同时工作的电流需求**：
```
空载总电流：  4 × 200mA   = 0.8A
运动总电流：  4 × 500mA   = 2.0A
堵转总电流：  4 × 1200mA  = 4.8A (峰值)
```

**电源容量选择建议**：
- 最小持续电流：**2A**
- 推荐持续电流：**3A**
- 峰值电流能力：**5A**

**电源功率计算**：
```
额定功率 = 8.4V × 3A = 25.2W
建议选择：30W 或以上的电源适配器
```

#### 电压转换解决方案

##### 方案1：DC-DC降压模块（推荐）⭐

**推荐型号**：
- **LM2596 降压模块**
  - 输入：4.5V - 40V
  - 输出：1.25V - 37V 可调
  - 最大电流：3A
  - 效率：92%
  - 价格：5-10元

- **XL4015 降压模块**（大电流版本）
  - 输入：8V - 36V
  - 输出：1.25V - 32V 可调
  - 最大电流：5A
  - 效率：96%
  - 价格：10-15元

**接线方法**：
```
12V电源 ──┬──> DC-DC降压模块 ──> 8.4V输出 ──> 舵机VCC
          │         ↓                          ↓
          └──────> GND ────────────────────> GND
```

**调节步骤**：
1. 不接负载，先给降压模块供电
2. 用万用表测量输出端电压
3. 调节模块上的电位器，将输出调至**8.4V**
4. 反复微调，确保电压稳定在8.4V ±0.1V
5. 连接舵机，再次测量带载电压（可能略有下降）
6. 微调至8.4V

##### 方案2：线性稳压器（小功率）

**适用场景**：单个舵机，功率小于5W

**型号选择**：
- **LM7808** (输出8V，1A)
- **LM317** (可调输出，1.5A)

**缺点**：
- 效率低（约60-70%）
- 发热严重（12V→8.4V，约30%能量变成热量）
- 需要大散热片
- 不适合多舵机应用

##### 方案3：使用专用舵机电源

**推荐产品**：
- 8.4V / 3A 开关电源适配器
- 2S锂电池（7.4V标称，8.4V满电）

**优点**：
- 电压完全匹配
- 无需额外转换
- 效率最高

**2S锂电池方案**：
```
2S锂电池（7.4V/8.4V）
├─ 容量：2200mAh - 5000mAh
├─ 持续放电：20C - 30C
├─ 工作时间：2200mAh ÷ 2A = 1小时以上
└─ 需要专用充电器
```

##### 方案4：分离供电（最佳方案）

**系统架构**：
```
12V电源 ──┬──> ART-PI主板 (12V/5V)
          │
          ├──> ESP32驱动板 (5V/3.3V)
          │
          └──> DC-DC降压 ──> 8.4V ──> 4个舵机
                                     (共地)
```

**优点**：
- 各部分电压独立，互不干扰
- 舵机大电流不影响控制板
- 便于故障排查
- 最稳定的供电方案

**注意事项**：
- ⚠️ **必须共地**：所有电源的GND必须连接在一起
- ⚠️ **粗线供电**：舵机电源线建议使用≥20AWG（0.5mm²）
- ⚠️ **电容滤波**：在舵机电源端并联1000μF电容，减少电流尖峰

#### 电源问题诊断方法

##### 1. 用万用表测量电压
```
测量点：
1. 电源输出端空载电压
2. 电源输出端带载电压（舵机运行时）
3. 舵机VCC引脚电压
4. 舵机运动瞬间的电压降

判断标准：
✓ 空载与带载电压差 < 0.5V  → 电源容量足够
✗ 空载与带载电压差 > 1.0V  → 电源容量不足
✗ 运动瞬间电压跌落 > 1.5V  → 需要加大滤波电容
```

##### 2. 观察舵机工作状态
```
正常工作：
✓ 运动平稳，无抖动
✓ 速度均匀
✓ 无异常声音
✓ 舵机外壳不发热（微温正常）

电压过高：
✗ 抖动、颤动
✗ 异常发热
✗ 有刺耳声音
✗ 控制失灵

电压过低：
✗ 扭矩不足
✗ 速度慢
✗ 堵转无力
```

##### 3. 电流测量
使用电流表串联测量：
```
电流表 ──> 舵机VCC

正常电流：
空载：    100-200mA
运动：    300-500mA
堵转：    800-1200mA

异常电流：
> 1500mA持续  → 电压过低或机械卡死
< 50mA        → 舵机损坏或未通电
```

#### 实际应用建议

**本项目最佳配置**：
```
方案：12V输入 + DC-DC降压

硬件清单：
1. XL4015降压模块 (5A) × 1    ￥12
2. 12V/3A电源适配器 × 1       ￥20
3. 1000μF/16V电解电容 × 2     ￥2
4. 杜邦线/端子线若干           ￥5
   总成本：约￥40

接线图：
                    ┌─────────────┐
    12V电源 ────────┤ DC-DC降压   │
       GND ─────────┤  (调至8.4V)  ├────┬──> 舵机0 VCC
                    └─────────────┘    ├──> 舵机1 VCC
                         │             ├──> 舵机2 VCC
                        GND ───────────┴──> 舵机3 VCC
                         │                      │
                         └──────────────────────┘
                                   (共地)
```

**调试步骤**：
1. ✅ 调节降压模块输出至8.4V（空载）
2. ✅ 连接单个舵机，测量电压（应≥8.2V）
3. ✅ 连接所有舵机，测量电压（应≥8.0V）
4. ✅ 让舵机运动，观察电压波动（应≤0.5V）
5. ✅ 如电压降过大，增加滤波电容或更换更大功率模块

**长期使用注意事项**：
- 🔍 定期检查舵机温度（正常应≤40℃）
- 🔍 定期测量电源电压（防止元件老化导致输出漂移）
- 🔍 观察舵机运动是否平稳
- 🔍 检查接线端子是否松动

---

### 📚 知识扩展：电源设计要点

#### 1. 为什么不能用电阻分压？
```
12V ──┬─── 100Ω ───┬─── 输出
      │            │
      └─── 200Ω ───┴─── GND

理论输出 = 12V × 200/(100+200) = 8V
```

**问题**：
- ✗ 电阻分压输出电压会随负载变化
- ✗ 舵机电流大（0.5A），电阻功耗 = I²R，会发热严重
- ✗ 效率极低，大部分能量浪费在电阻上
- ✗ 电压不稳定，根本无法使用

#### 2. DC-DC降压原理（开关电源）
```
工作原理：通过高频开关+电感储能实现降压
效率：90-96%（远高于线性稳压）
优点：高效、发热小、输出稳定
```

#### 3. 功率预算计算
```
系统总功率计算：
┌─────────────────────────────────┐
│ ART-PI主板    :  0.5W  (5V/100mA) │
│ ESP32驱动板   :  1.0W  (5V/200mA) │
│ 4个舵机(运动) : 16.8W  (8.4V/2A)  │
│ 合计          : 18.3W             │
│ 余量(×1.5)    : 27.5W             │
│ 推荐电源      : 30W               │
└─────────────────────────────────┘
```

#### 4. 滤波电容的作用
```
作用：
1. 平滑电压波动
2. 抑制电流尖峰（舵机启动瞬间）
3. 改善高频噪声

选择：
- 容值：1000μF - 2200μF
- 耐压：≥ 1.5倍工作电压（8.4V用16V电容）
- 类型：低ESR电解电容
- 位置：尽量靠近舵机电源引脚
```

---

### 🎯 技术特点

1. **智能舵机切换**：自动跟踪当前活动舵机ID，最小化HTTP请求次数
2. **线程安全设计**：使用互斥锁保护，支持多线程调用
3. **灵活速度控制**：4级速度可调，适应不同应用场景
4. **批量操作优化**：一次性控制多个舵机，提高效率
5. **动作序列编程**：支持复杂动作组合，延时控制精确
6. **预设动作库**：常用动作一键执行，简化测试和演示
7. **电源管理经验**：正确的电压选择是硬件稳定运行的基础

---

### 📝 使用示例

#### 快速开始
```shell
# 1. 连接ESP32的WiFi
connect_esp32

# 2. 控制单个舵机
serv move 0 0 2          # 舵机0到中间位置，中速

# 3. 控制所有舵机
serv all_mid 3           # 所有舵机快速回中位

# 4. 波浪演示
serv wave 3 2            # 执行3次波浪动作

# 5. 全功能测试
servo_test
```

#### 编程示例
```c
// 复杂动作序列
void custom_action(void)
{
    // 舵机0和1同时向上
    int ids1[] = {0, 1};
    int pos1[] = {SERVO_POS_MAX, SERVO_POS_MAX};
    servo_multi_move(ids1, pos1, 2);
    rt_thread_mdelay(1000);

    // 舵机2和3同时向下
    int ids2[] = {2, 3};
    int pos2[] = {SERVO_POS_MIN, SERVO_POS_MIN};
    servo_multi_move(ids2, pos2, 2);
    rt_thread_mdelay(1000);

    // 所有舵机回中位
    servo_all_middle();
}
```

---

### 📂 项目文件结构

```
Cc/applications/
├── main.c                      # 主程序
├── wifi_manager.c/h            # WiFi管理模块
├── servo_http_client.c/h       # HTTP客户端模块
├── servo_control.c/h           # 基础舵机控制
├── servo_advanced.c/h          # 高级舵机控制
└── servo_msh_advanced.c        # 高级MSH命令
```

---

### 🔄 下一步开发计划

#### 阶段2：串口屏显示模块（即将开始）📱

**功能需求**：
- 实时显示WiFi连接状态
- 显示4个舵机当前位置和状态
- 显示肌电信号强度（图形化）
- 显示系统运行状态和错误信息
- 支持触摸操作（可选）

**技术方案**：
```
串口屏型号建议：
- 迪文/大彩 串口屏
- 尺寸：3.5寸 - 7寸
- 通信：UART (115200bps)
- 协议：简单指令协议
```

**开发任务**：
1. **UART驱动配置**
   - 配置RT-Thread UART设备
   - 波特率：115200
   - 数据格式：8N1

2. **显示协议封装**
   - 封装串口屏指令集
   - 文本显示函数
   - 图形绘制函数
   - 界面布局设计

3. **界面设计**
   ```
   ┌─────────────────────────────┐
   │  外骨骼手指控制系统 v1.0     │
   ├─────────────────────────────┤
   │ WiFi: ●已连接 192.168.4.10  │
   │                             │
   │ 舵机状态:                    │
   │  [食指  ] ████████░░ 80%    │
   │  [中指  ] ██████░░░░ 60%    │
   │  [无名指] ████░░░░░░ 40%    │
   │  [小指  ] ██░░░░░░░░ 20%    │
   │                             │
   │ 肌电信号:                    │
   │  通道1: ▂▃▅▇█▇▅▃▂ 65%      │
   │  通道2: ▂▃▄▅▄▃▂▁ 45%       │
   │                             │
   │ 系统: 运行正常  温度: 35℃   │
   └─────────────────────────────┘
   ```

4. **数据更新策略**
   - 使用RT-Thread线程定时刷新
   - 更新频率：10-20Hz
   - 局部刷新减少闪烁

**预计工作量**：2-3天

---

#### 阶段3：肌电信号采集与处理（核心功能）💪

**功能需求**：
- 通过UART接收肌电臂环数据
- 实时处理肌电信号
- 将肌电强度映射到舵机位置
- 支持阈值调节和死区设置
- 四通道独立控制四个手指

**技术方案**：

##### 1. 肌电臂环接口
```c
/* 肌电数据结构 */
typedef struct {
    uint16_t channel[4];      // 4通道肌电值 (0-1023)
    uint8_t  valid;           // 数据有效标志
    uint32_t timestamp;       // 时间戳
} emg_data_t;

/* 肌电采集API */
int emg_init(const char *uart_name);
int emg_read(emg_data_t *data, int timeout_ms);
int emg_calibrate(void);  // 校准函数
```

##### 2. 信号处理流程
```
原始肌电信号 (ADC值)
    ↓
滤波处理 (移动平均/低通滤波)
    ↓
幅值检测 (RMS/MAV)
    ↓
归一化 (0-100%)
    ↓
阈值判断 (死区+灵敏度)
    ↓
映射到舵机位置 (0-180°)
    ↓
舵机控制命令
```

##### 3. 映射算法
```c
/**
 * @brief 肌电信号到舵机位置的映射
 * @param emg_value  肌电信号强度 (0-100)
 * @param threshold  触发阈值 (10-30)
 * @param deadzone   死区范围 (0-10)
 * @return 舵机位置 (0=最小, 1=中间, 2=最大)
 */
int emg_to_servo_position(int emg_value, int threshold, int deadzone)
{
    if (emg_value < threshold + deadzone) {
        return SERVO_POS_MIN;  // 放松状态
    }
    else if (emg_value < 50 + deadzone) {
        return SERVO_POS_MIDDLE;  // 半握
    }
    else {
        return SERVO_POS_MAX;  // 全握
    }
}
```

##### 4. 实时控制线程
```c
/* 肌电控制线程 */
void emg_control_thread_entry(void *parameter)
{
    emg_data_t emg_data;
    int servo_positions[4];

    while (1)
    {
        // 1. 读取肌电数据
        if (emg_read(&emg_data, 100) == 0)
        {
            // 2. 处理每个通道
            for (int i = 0; i < 4; i++)
            {
                // 信号处理
                int emg_value = process_emg_signal(emg_data.channel[i]);

                // 映射到舵机位置
                servo_positions[i] = emg_to_servo_position(
                    emg_value,
                    g_config.threshold[i],
                    g_config.deadzone
                );
            }

            // 3. 批量控制舵机
            servo_multi_move(
                (int[]){0, 1, 2, 3},
                servo_positions,
                4
            );

            // 4. 更新显示
            display_update_emg(emg_data.channel, 4);
            display_update_servo(servo_positions, 4);
        }

        rt_thread_mdelay(50);  // 20Hz控制频率
    }
}
```

##### 5. 校准流程
```
校准步骤：
1. 采集静息状态基线（5秒）
2. 采集最大收缩值（用力握拳，3次×3秒）
3. 计算动态阈值
4. 保存校准参数到Flash

校准参数：
- baseline[4]：静息基线
- max_value[4]：最大值
- threshold[4]：触发阈值 = baseline + (max - baseline) * 0.3
- deadzone：死区 = (max - baseline) * 0.1
```

**开发任务**：
1. ✅ **UART通信驱动**
   - 配置肌电臂环UART端口
   - 数据帧格式解析
   - CRC校验（如果有）

2. ✅ **信号处理模块**
   - 移动平均滤波器
   - RMS幅值计算
   - 归一化处理

3. ✅ **映射算法实现**
   - 线性映射
   - 非线性映射（可选：S曲线）
   - 阈值和死区处理

4. ✅ **实时控制线程**
   - 周期性采集肌电数据
   - 实时处理和控制
   - 错误处理和超时保护

5. ✅ **校准功能**
   - 交互式校准流程
   - 参数保存和加载
   - MSH校准命令

6. ✅ **性能优化**
   - 减少延迟（目标<50ms）
   - 平滑控制（防止抖动）
   - 资源占用优化

**预计工作量**：5-7天

---

#### 阶段4：系统集成与优化

**功能需求**：
- 三模式切换：手动模式、肌电模式、演示模式
- 参数配置界面（通过串口屏）
- 数据记录和回放
- 故障诊断和安全保护

**开发任务**：
1. **模式管理**
   ```c
   typedef enum {
       MODE_MANUAL,    // 手动模式（MSH命令）
       MODE_EMG,       // 肌电控制模式
       MODE_DEMO,      // 演示模式（预设动作）
   } control_mode_t;
   ```

2. **安全保护**
   - 过流保护检测
   - 超温保护
   - 失控保护（肌电信号丢失）
   - 紧急停止功能

3. **参数配置系统**
   - 舵机速度、位置范围
   - 肌电阈值、死区、灵敏度
   - 显示刷新率
   - 参数持久化存储

4. **性能优化**
   - 降低系统延迟
   - 优化电源管理
   - 代码优化和重构

**预计工作量**：3-4天

---

#### 阶段5：测试与完善

**测试内容**：
1. **功能测试**
   - 单舵机控制测试
   - 多舵机协同测试
   - 肌电信号响应测试
   - 显示界面测试

2. **性能测试**
   - 延迟测试（肌电信号→舵机响应）
   - 稳定性测试（长时间运行）
   - 精度测试（位置控制精度）

3. **极限测试**
   - 快速连续动作
   - 负载测试
   - 环境适应性

4. **用户体验测试**
   - 佩戴舒适度
   - 控制灵敏度
   - 疲劳度测试

**预计工作量**：3-5天

---

### 📅 总体时间规划

```
┌──────────────────────────────────────────────────────┐
│                   项目时间轴                          │
├──────────────────────────────────────────────────────┤
│ 阶段1: WiFi舵机控制        │ ✅ 已完成 (2025-11-14)  │
│ 阶段2: 串口屏显示          │ ✅ 已完成 (2025-11-15)  │
│ 阶段3: 肌电信号控制        │ ⏳ 即将开始             │
│ 阶段4: 系统集成优化        │ ⏳                     │
│ 阶段5: 测试与完善          │ ⏳                     │
├──────────────────────────────────────────────────────┤
│ 预计总工期: 2-3周                                     │
└──────────────────────────────────────────────────────┘
```

---

### 🎯 项目里程碑

- ✅ **里程碑1**：WiFi舵机控制基础功能（2025-11-14完成）
- ✅ **里程碑2**：串口屏显示系统状态（2025-11-15完成）
- 🎯 **里程碑3**：肌电信号实时控制单手指
- 🎯 **里程碑4**：四指独立控制
- 🎯 **里程碑5**：完整系统演示

---

### 💡 技术难点预判

#### 难点1：肌电信号噪声处理
**挑战**：肌电信号容易受到环境干扰

**解决方案**：

- 硬件滤波（如果臂环支持）
- 软件多级滤波（移动平均+卡尔曼滤波）
- 自适应阈值调整

#### 难点2：控制延迟优化
**挑战**：WiFi通信+HTTP协议存在延迟

**解决方案**：

- 优化HTTP请求（保持连接、减少握手）
- 批量发送命令（4个舵机一次发送）
- 预测性控制（根据肌电变化趋势）

#### 难点3：舵机响应平滑度
**挑战**：直接映射会导致舵机抖动

**解决方案**：

- 信号平滑处理（滑动窗口）
- 位置差值插补
- 速度限制保护

#### 难点4：电源管理
**挑战**：4个舵机同时动作电流大

**解决方案**：

- 已解决：DC-DC降压至8.4V
- 增加大容量电容
- 监控电压降，必要时降低速度

---

### 💡 重要提示

#### 软件使用
1. **使用前必须先连接WiFi**：`connect_esp32`
2. **舵机ID范围**：0-3（共4个舵机）
3. **速度级别**：1-4，0表示使用当前速度
4. **位置定义**：0=中间，1=最大，2=最小
5. **线程安全**：所有API均可在多线程中调用
6. **ESP32地址**：默认192.168.4.1（AP模式）

#### 硬件注意事项 ⚠️
1. **电压匹配**：舵机额定8.4V，必须使用降压模块，不能直接12V供电！
2. **电流容量**：4个舵机至少需要3A电源
3. **共地连接**：所有电源GND必须连接
4. **滤波电容**：建议在舵机电源端并联1000μF电容
5. **定期检查**：测量电压、观察温度、检查接线

---

## 2025-11-15 开发记录

### ✅ 完成的功能模块

#### 6. HMI串口屏显示模块 (hmi_display.c/h)

实现了完整的TJC/迪文串口屏驱动系统,支持双向通信、控件操作和事件回调。

**硬件配置**：
- **UART端口**：UART1 (PA9/PA10)
- **波特率**：115200 baud
- **数据格式**：8N1（8数据位,无校验,1停止位)
- **接线**：
  ```
  STM32H7RS          串口屏
  ┌────────┐      ┌────────┐
  │  PA9   ├─────>│  RX    │
  │  PA10  │<─────┤  TX    │
  │  GND   ├──────┤  GND   │
  │  5V    ├──────┤  VCC   │
  └────────┘      └────────┘
  ```

**通信协议**：

1. **发送协议**（STM32→串口屏）：
   ```
   指令字符串 + 0xFF + 0xFF + 0xFF
   
   例如：
   "t0.txt=\"Hello\"" + 0xFF + 0xFF + 0xFF
   ```

2. **接收协议**（串口屏→STM32）：
   ```
   帧格式：7字节固定长度
   ┌──────┬─────────┬────────┬────────┬──────┬──────┬──────┐
   │ 0x55 │ cmd_type│ data2  │ data3  │ 0xFF │ 0xFF │ 0xFF │
   └──────┴─────────┴────────┴────────┴──────┴──────┴──────┘
   
   命令类型：
   - 0x01：按钮点击事件
   - 0x02：滑块h0值变化
   - 0x03：滑块h1值变化
   ```

**关键函数**：

```c
/* 初始化和线程管理 */
int hmi_init(void);                    // 初始化HMI驱动
int hmi_start_thread(void);            // 启动接收线程

/* 基础通信函数 */
int hmi_send_string(const char *str);  // 发送字符串命令
int hmi_set_text(const char *obj_name, const char *text);  // 设置文本
int hmi_set_value(const char *obj_name, int value);        // 设置数值
int hmi_set_button_state(const char *btn_name, int pressed);  // 模拟按钮

/* 高级更新函数 */
void hmi_update_wifi_status(const char *ssid, const char *ip, int rssi);
void hmi_update_servo_pos(int servo_id, int position);
void hmi_update_servo_speed(int servo_id, int speed);
void hmi_update_cpu_usage(int percent);
void hmi_update_memory_info(int used_kb, int total_kb);
void hmi_update_runtime(int seconds);

/* 用户回调（在hmi_callbacks.c中实现） */
void hmi_on_button_click(int button_id, int state);
void hmi_on_slider_change(int slider_id, int value);
```

**控件名称映射表**：

| 功能 | 控件类型 | 控件名称 | 说明 |
|------|---------|---------|------|
| WiFi状态 | 文本 | `t_wifi` | 显示SSID或"Disconnected" |
| IP地址 | 文本 | `t_ip` | 显示IP地址 |
| 信号强度 | 数值 | `n_rssi` | WiFi RSSI值 |
| 舵机1位置 | 数值 | `n_servo1` | 舵机1当前位置(0-4095) |
| 舵机2位置 | 数值 | `n_servo2` | 舵机2当前位置(0-4095) |
| 舵机3位置 | 数值 | `n_servo3` | 舵机3当前位置(0-4095) |
| 舵机4位置 | 数值 | `n_servo4` | 舵机4当前位置(0-4095) |
| 舵机1速度 | 滑块 | `h_speed1` | 舵机1速度控制 |
| 舵机2速度 | 滑块 | `h_speed2` | 舵机2速度控制 |
| 舵机3速度 | 滑块 | `h_speed3` | 舵机3速度控制 |
| 舵机4速度 | 滑块 | `h_speed4` | 舵机4速度控制 |
| CPU使用率 | 文本 | `t_cpu` | CPU: xx% |
| 内存信息 | 文本 | `t_mem` | Mem: xxx/xxx KB |
| 运行时间 | 文本 | `t_time` | HH:MM:SS |
| 消息文本 | 文本 | `t_msg` | 通用消息显示 |

**技术实现细节**：

1. **环形缓冲区**：
   ```c
   typedef struct {
       uint16_t head;    // 读指针
       uint16_t tail;    // 写指针
       uint16_t length;  // 当前数据长度
       uint8_t  data[500];  // 缓冲区
   } hmi_ringbuffer_t;
   ```
   - 缓冲区大小：500字节
   - 支持中断安全写入
   - 自动循环读写

2. **接收线程**：
   ```c
   优先级：15
   栈大小：2048字节
   更新周期：事件驱动（信号量触发）
   ```
   - UART中断接收数据
   - 写入环形缓冲区
   - 释放信号量唤醒线程
   - 线程解析完整帧并调用回调

3. **帧解析**：
   ```c
   while (buffer_length >= 7)  // 完整帧长度
   {
       if (frame[0] == 0x55 &&      // 帧头
           frame[4] == 0xFF &&      // 帧尾1
           frame[5] == 0xFF &&      // 帧尾2
           frame[6] == 0xFF)        // 帧尾3
       {
           process_frame();  // 处理帧
           delete_frame();   // 删除已处理帧
       }
       else
       {
           skip_one_byte();  // 跳过无效字节
       }
   }
   ```

4. **系统信息更新线程**（main.c）：
   ```c
   优先级：20
   栈大小：2048字节
   更新周期：1秒
   
   更新内容：
   - 系统运行时间（HH:MM:SS格式）
   - CPU使用率（暂为占位值15%）
   - 内存使用（已用/总计KB）
   ```

**集成点**：

1. **WiFi管理模块**（wifi_manager.c）：
   ```c
   // WiFi连接成功
   case RT_WLAN_EVT_READY:
       hmi_update_wifi_status(ssid, ip, rssi);
       hmi_set_text("t_msg", "WiFi Connected!");
       break;
   
   // WiFi断开
   case RT_WLAN_EVT_STA_DISCONNECTED:
       hmi_update_wifi_status(NULL, NULL, 0);
       hmi_set_text("t_msg", "WiFi Disconnected");
       break;
   ```

2. **舵机控制模块**（servo_advanced.c）：
   ```c
   // 舵机移动成功后更新显示
   if (ret == 0)
   {
       hmi_update_servo_pos(servo_id, position);
   }
   ```

3. **主程序**（main.c）：
   ```c
   // 初始化HMI
   if (hmi_init() == RT_EOK)
   {
       hmi_start_thread();
       hmi_set_text("t_msg", "System Ready!");
   
       // 初始化舵机位置显示
       hmi_update_servo_pos(1, 0);
       hmi_update_servo_pos(2, 0);
       hmi_update_servo_pos(3, 0);
       hmi_update_servo_pos(4, 0);
   
       // 创建系统信息更新线程
       rt_thread_create("sys_info", sys_info_thread_entry, ...);
   }
   ```

**用户回调模板**（hmi_callbacks.c）：

提供了完整的事件处理模板,用户可根据需求自定义：

```c
void hmi_on_button_click(int button_id, int state)
{
    switch (button_id)
    {
        case 1:  // 舵机1控制按钮
            servo_move_by_id_speed(1, 2048, SERVO_SPEED_MEDIUM);
            hmi_set_text("t_msg", "Servo 1 -> Mid");
            break;

        case 10:  // 回中按钮
            servo_preset_home();
            hmi_set_text("t_msg", "All Servos Home");
            break;

        // ... 更多按钮
    }
}

void hmi_on_slider_change(int slider_id, int value)
{
    switch (slider_id)
    {
        case 0:  // h0滑块控制舵机1速度
            int speed = (value / 64) + 1;  // 映射0-255到1-4
            hmi_update_servo_speed(1, value);
            break;

        // ... 更多滑块
    }
}
```

**MSH测试命令**：

```shell
# 设置文本
hmi_test text t0 "Hello World"

# 设置数值
hmi_test value n0 2048

# 模拟按钮点击
hmi_test button b0 1

# 测试WiFi显示
hmi_test wifi

# 测试舵机显示
hmi_test servo 1 2048

# 测试系统信息
hmi_test system
```

---

### 📂 项目文件结构更新

```
Cc/applications/
├── main.c                      # 主程序（新增HMI初始化和系统线程）
├── wifi_manager.c/h            # WiFi管理模块（新增HMI更新）
├── servo_http_client.c/h       # HTTP客户端模块
├── servo_control.c/h           # 基础舵机控制
├── servo_advanced.c/h          # 高级舵机控制（新增HMI更新）
├── servo_msh_advanced.c        # 高级MSH命令
├── hmi_display.c/h             # ⭐ HMI显示驱动（新增）
└── hmi_callbacks.c             # ⭐ HMI事件回调模板（新增）
```

**配置文件修改**：

```
rtconfig.h:
- 启用 BSP_USING_UART1
- RX缓冲: 512字节
- TX缓冲: 256字节

board.h:
- UART1引脚已定义（PA9/PA10）
```

---

### 🎯 技术特点

1. **双向通信**：支持STM32发送命令和接收串口屏事件
2. **事件驱动**：基于信号量的异步接收机制,无阻塞
3. **环形缓冲**：高效的中断安全数据缓冲,防止数据丢失
4. **帧同步**：可靠的帧头帧尾验证,自动纠错
5. **模板化设计**：用户回调函数完全可定制,提供丰富示例
6. **模块化架构**：驱动层、业务层分离,易于维护
7. **线程安全**：UART操作和缓冲区访问均为中断安全
8. **实时更新**：WiFi、舵机、系统状态自动更新显示

---

### 📝 使用示例

#### 示例1：控制文本显示
```c
// 显示欢迎消息
hmi_set_text("t_msg", "System Ready!");

// 显示WiFi状态
hmi_set_text("t_wifi", "WiFi: Connected");

// 显示IP地址
hmi_set_text("t_ip", "192.168.4.10");
```

#### 示例2：更新舵机位置
```c
// 控制舵机并自动更新显示
servo_move_by_id_speed(1, 2048, SERVO_SPEED_MEDIUM);
// HMI显示会自动更新为2048

// 批量更新显示
for (int i = 1; i <= 4; i++)
{
    hmi_update_servo_pos(i, 2048);
}
```

#### 示例3：按钮控制舵机
在HMI界面创建按钮,设置发送事件:
```
按钮ID: 1
点击事件: 发送 55 01 01 01 FF FF FF
```

在`hmi_callbacks.c`中处理:
```c
case 1:
    servo_move_by_id_speed(1, SERVO_POS_MIDDLE, SERVO_SPEED_MEDIUM);
    hmi_set_text("t_msg", "Servo 1 -> Mid");
    break;
```

#### 示例4：滑块控制速度
在HMI界面创建滑块h0,范围0-255,设置变化事件。

在`hmi_callbacks.c`中处理:
```c
case 0:  // h0滑块
    int speed_level = (value / 64) + 1;  // 映射到1-4
    // 保存速度设置供下次移动使用
    servo_all_set_speed(speed_level);
    hmi_update_servo_speed(1, value);
    break;
```

#### 示例5：显示系统信息
```c
// 在定时线程中更新
while (1)
{
    // 更新运行时间
    rt_uint32_t runtime_sec = (rt_tick_get() - start_tick) / RT_TICK_PER_SECOND;
    hmi_update_runtime(runtime_sec);  // 显示为 HH:MM:SS

    // 更新CPU使用率
    hmi_update_cpu_usage(25);  // 25%

    // 更新内存信息
    rt_uint32_t total, used, max_used;
    rt_memory_info(&total, &used, &max_used);
    hmi_update_memory_info(used / 1024, total / 1024);  // KB

    rt_thread_mdelay(1000);  // 1秒更新一次
}
```

---

### 💡 开发经验

#### 经验1：UART配置要点
- **缓冲区大小**：RX建议512字节以上,防止高速数据丢失
- **中断模式**：必须使用`RT_DEVICE_FLAG_INT_RX`中断接收
- **回调函数**：在回调中只写缓冲区,不做复杂处理
- **共享资源**：环形缓冲区读写需考虑中断安全

#### 经验2：协议设计
- **帧尾标识**：3个0xFF作为帧尾,便于同步
- **固定长度**：接收帧固定7字节,简化解析
- **校验机制**：帧头+帧尾双重验证,提高可靠性
- **容错处理**：遇到错误数据跳过1字节继续搜索

#### 经验3：事件回调设计
- **模板函数**：提供完整示例,降低用户学习成本
- **switch-case**：清晰的ID映射,易于扩展
- **业务分离**：回调只处理逻辑,不直接操作硬件
- **错误处理**：未知ID打印警告,不影响系统运行

#### 经验4：显示更新策略
- **按需更新**：只在状态变化时更新,减少通信量
- **批量操作**：初始化时批量设置,运行时按需更新
- **优先级**：重要信息（WiFi、舵机）实时更新,系统信息定时更新
- **格式化**：统一格式（如"CPU: 25%"）,提高可读性

---

### 🔧 故障排查指南

#### 问题1：串口屏无显示
**检查项**：
1. ✅ 串口线是否接反（TX接RX,RX接TX）
2. ✅ 波特率是否匹配（115200）
3. ✅ 电源是否正常（5V）
4. ✅ 控件名称是否正确（区分大小写）

**调试方法**：
```shell
# 使用示波器或逻辑分析仪查看TX线
# 应该看到数据+0xFF 0xFF 0xFF的波形
```

#### 问题2：接收不到按钮事件
**检查项**：
1. ✅ HMI界面是否设置了发送事件
2. ✅ 发送格式是否正确（55 01 xx xx FF FF FF）
3. ✅ 接收线程是否启动（`hmi_start_thread()`）
4. ✅ 回调函数是否正确实现

**调试方法**：
```c
// 在hmi_uart_rx_indicate()中添加日志
LOG_D("RX: 0x%02X", ch);

// 在hmi_process_frame()中添加日志
LOG_D("Frame: %02X %02X %02X", cmd_type, data2, data3);
```

#### 问题3：显示更新不及时
**可能原因**：
- 发送命令过快,串口屏来不及处理
- 缓冲区溢出

**解决方案**：
```c
// 批量更新时添加短暂延时
hmi_set_text("t0", "Text1");
rt_thread_mdelay(10);
hmi_set_text("t1", "Text2");
```

#### 问题4：中文显示乱码
**原因**：编码格式不匹配

**解决方案**：
- 确保源代码UTF-8编码
- 串口屏设置为UTF-8编码
- 或使用GBK编码(根据串口屏型号)

---

### 📚 参考资料

- TJC/迪文串口屏用户手册
- RT-Thread UART设备驱动文档
- 环形缓冲区设计模式
- 串口通信协议设计指南

---

## 开发统计

### 2025-11-14 统计
- **代码文件**：10个（.c/.h）
- **MSH命令**：15+个
- **API函数**：30+个
- **解决问题**：6个（5个软件 + 1个硬件）
- **功能模块**：4个主要模块

### 2025-11-15 统计
- **新增文件**：3个（hmi_display.c/h, hmi_callbacks.c）
- **修改文件**：4个（rtconfig.h, main.c, servo_advanced.c, wifi_manager.c）
- **新增MSH命令**：1个（hmi_test）
- **新增API函数**：13个
- **新增线程**：2个（HMI接收线程、系统信息线程）
- **功能模块**：1个（HMI显示驱动）

### 项目总计
- **开发周期**：2天（2025-11-14 ~ 2025-11-15）
- **总代码文件**：13个（.c/.h）
- **总MSH命令**：16+个
- **总API函数**：43+个
- **总功能模块**：5个（WiFi + HTTP + 舵机基础 + 舵机高级 + HMI显示）
- **总线程数**：3个（HMI接收、系统信息、主线程）

---

## 参考资料

- RT-Thread官方文档
- ESP32 Arduino参考
- SCSCL舵机协议文档
- lwIP网络栈文档
- DC-DC降压模块应用笔记
- 舵机电源设计指南
